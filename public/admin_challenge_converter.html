<!DOCTYPE html>
<html lang="ko">
<head>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Challenge Gunsan Unified Parser (2022-2025)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        body { font-family: 'Pretendard', sans-serif; }
    </style>
</head>
<body class="bg-slate-50 min-h-screen flex items-center justify-center p-6 text-slate-800">

    <div class="bg-white rounded-3xl p-10 max-w-xl w-full shadow-xl border border-slate-100 text-center">
        <div class="mb-8">
            <div class="inline-flex items-center justify-center w-20 h-20 rounded-full bg-blue-50 mb-6 text-blue-600">
                <i class="fas fa-file-pdf text-3xl"></i>
            </div>
            <h1 class="text-3xl font-black text-slate-800 mb-2">챌린지 기록 변환기</h1>
            <p class="text-slate-500 font-medium">2022 ~ 2025 시즌 통합 (PDF/CSV to JSON)</p>
        </div>
        
        <label class="block w-full cursor-pointer bg-slate-50 border-4 border-dashed border-slate-200 rounded-3xl p-12 hover:border-blue-500 hover:bg-blue-50/30 transition-all group">
            <input type="file" id="pdfInput" accept=".pdf,.csv,.xls,.xlsx" class="hidden" />
            <i class="fas fa-cloud-upload-alt text-5xl text-slate-300 group-hover:text-blue-500 mb-4 transition-colors"></i>
            <span class="block font-bold text-slate-700 text-lg mb-1">PDF/CSV/Excel 파일 선택</span>
            <p id="fileLabel" class="text-sm text-slate-400">클릭하거나 파일을 여기로 드래그하세요</p>
        </label>

        <div id="status" class="mt-8 hidden">
            <div class="flex items-center justify-center gap-2 text-blue-600 font-bold animate-pulse">
                <i class="fas fa-spinner fa-spin"></i> 데이터 분석 및 변환 중...
            </div>
        </div>
    </div>

    <script>
        // PDF.js 워커 설정
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        function downloadJSON(data, originalFilename) {
            if (!data || data.length === 0) {
                throw new Error("추출된 데이터가 없습니다. 파일 내용을 확인해주세요.");
            }
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            
            const isHalf = originalFilename.toLowerCase().includes("half");
            const yearMatch = originalFilename.match(/202\d/);
            const yearVal = yearMatch ? yearMatch[0] : "data";

            a.download = isHalf ? `challenge-gunsan_half_${yearVal}.json` : `challenge-gunsan_${yearVal}.json`;
            a.click();
            document.getElementById('status').innerText = `성공! ${data.length}건 다운로드됨.`;
        }

        // --- 필드 정의 영역 ---
        
        // 1. 2025 코스 마스터 키 (33개)
        const MASTER_KEYS = [
            "Bib", "NameKR", "NameEN", "CourseInfo", "Category", "Gender", "RaceTime", 
            "Swim", "T1", "Bike", "T2", "Run", 
            "Start", 
            "swimCheck", "swimEnd", 
            "bikeStart", "bike1Check1", "bike3Check1", "bike4Check1", "bike1Check2", "bike3Check2", "bike4Check2", "bikeEnd", 
            "runStart", "run2Check1", "run1Check1", "run2Check2", "run1Check2", "run2Check3", "run1Check3", 
            "run2Check4", "run1Check4", 
            "Finish"
        ];

        const KEYS_2023 = [
            "Bib", "FirstName", "FamilyName", "이름", "State", "PlaceCat", "RaceTime", 
            "Swim", "T1", "Bike", "T2", "Run", 
            "Start", 
            "swimCheck", "swimEnd", 
            "bikeStart", "bike1Check1", "bike3Check1", "bike4Check1","bike1Check2", "bike3Check2", "bike4Check2", "bikeEnd", 
            "runStart", "run2Check1", "run1Check1", "run2Check2", "run1Check2", "run2Check3", "run1Check3", "run2Check4", "run1Check4", 
            "Finish"
        ];
        const KEYS_HALF_2023 = [
            "Bib", "FirstName", "FamilyName", "이름", "State", "PlaceCat", "RaceTime", 
            "Swim", "T1", "Bike", "T2", "Run", 
            "Start", 
            "swimCheck", "swimEnd", 
            "bikeStart", "bike1Check1", "bike3Check1-null", "bike4Check1","bike1Check2-null", "bike3Check2-null", "bike4Check2-null", "bikeEnd", 
            "runStart", "run2Check1", "run1Check1-null", "run2Check2", "run1Check2-null", "run2Check3-null", "run1Check3-null", "run2Check4-null", "run1Check4-null", 
            "Finish"
        ];
        // 2. 2025 Half 코스 키 (23개)
        const KEYS_HALF_DETAILED = [
"배번호", "한글이름", "영문이름","단체명", "종목", "카테고리", "성별", "칩타임",
"Start Swim", "Finish Swim", "Start Bike", "Bike CP0", "Bike CP1", "Bike CP2", "Bike CP3", "Bike CP4", "Bike CP5", "Bike CP6", "Bike CP7", "Bike CP8", "Finish Bike",
"Run Start", "Run CP1", "Run CP2", "Run CP3", "Run CP4", "Run CP5", "Run CP6", "Run CP7", "Run CP8",
"Finish", "foul", "remarks", "종목순위", "종목인원", "성별순위", "성별인원", "부문순위", "부문인원"
        ];

        // 3. 2022년 전용 키 (10개)
        const KEYS_2022 = ["Bib", "FirstName", "FamilyName", "PlaceCat", "RaceTime", "Swim", "T1", "Bike", "T2", "Run"];

        const KEYS_2024 = ["순위", "배번호", "이름", "단체", "종목", "부문", "nationality", "성별", "칩타임", "Stage1", "T1", "Stage2", "T2", "Stage3", "status"];

        document.getElementById('pdfInput').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const originalName = file.name.substring(0, file.name.lastIndexOf('.'));
            const ext = file.name.split('.').pop().toLowerCase();
            
            document.getElementById('fileLabel').innerText = file.name;
            document.getElementById('status').classList.remove('hidden');
            document.getElementById('status').innerText = "데이터 분석 중...";
            
            let results = [];

            try {
                if (ext === 'xls' || ext === 'xlsx') {
                    const arrayBuffer = await file.arrayBuffer();
                    const workbook = XLSX.read(new Uint8Array(arrayBuffer), {type: 'array'});
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: "" });

                    const yearMatch = file.name.match(/202\d/);
                    const year = yearMatch ? yearMatch[0] : null;

                    if (!year) {
                        throw new Error("파일명에서 연도를 찾을 수 없습니다 (예: challenge_2023.xlsx).");
                    }

                    const isHalf = file.name.toLowerCase().includes("half");
                    let keys;
                    if (year === '2022') keys = KEYS_2022;
                    else if (year === '2023') keys = isHalf ? KEYS_HALF_2023 : KEYS_2023;
                    else if (year === '2024') keys = KEYS_2024;
                    else if (year === '2025') keys = KEYS_HALF_DETAILED ;
                    else throw new Error(year + "년에 해당하는 키 정의가 없습니다.");
                    
                    const dataRows = sheetData.slice(1); // 헤더 제외

                    results = dataRows.map(row => {
                        if (row.length < 5 || row.some(cell => typeof cell === 'string' && (cell.includes("DNS") || cell.includes("DNF")))) {
                            return null;
                        }
                        let record = { year: year };
                        let textIndex = 0;
                        keys.forEach((key) => {
                            if (key.endsWith('-null')) {
                                record[key] = "";
                            } else {
                                record[key] = row[textIndex] || "";
                                textIndex++;
                            }
                        });
                        return record;
                    }).filter(Boolean);

                } else if (ext === 'csv') {
                    const text = await file.text();
                    const lines = text.trim().split(/\r?\n/);
                    const yearMatch = file.name.match(/202\d/);
                    const year = yearMatch ? yearMatch[0] : "2024";
                    const keys = KEYS_2024;

                    results = lines.slice(1).map(line => {
                        const cols = line.split(',').map(c => c.trim().replace(/^"|"$/g, ''));
                        if (cols.length < 5 || cols.some(c => c.includes("DNS") || c.includes("DNF"))) return null;
                        let record = { year: year };
                        keys.forEach((key, index) => { record[key] = cols[index] || ""; });
                        return record;
                    }).filter(Boolean);

                } else { // PDF
                    const is2023 = file.name.includes("2023");
                    const is2025 = file.name.includes("2025");
                    const isHalf = file.name.toLowerCase().includes("half");
                    
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                    let lastCategory = "";

                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const rows = {};

                        // 텍스트 항목을 Y 좌표별로 그룹화
                        textContent.items.forEach(item => {
                            const y = Math.round(item.transform[5]);
                            if (!rows[y]) rows[y] = [];
                            rows[y].push({ x: item.transform[4], str: item.str.trim() });
                        });

                        const sortedY = Object.keys(rows).sort((a, b) => b - a);

                        sortedY.forEach(y => {
                            const row = rows[y].sort((a, b) => a.x - b.x);
                            const texts = row.map(r => r.str).filter(s => s !== "");
                            const lineText = texts.join(" ");

                            // [필터 1] DNS, DNF 선수는 데이터 꼬임 방지를 위해 즉시 제외
                            const upperLine = lineText.toUpperCase();
                            if (upperLine.includes("DNS") || upperLine.includes("DNF")) return;

                            // [카테고리 감지] 
                            if (lineText.includes("Full") || lineText.includes("Half") || lineText.includes("Age") || lineText.includes("코스")) {
                                if (!lineText.includes("Bib") && !/^\d/.test(lineText)) { 
                                    lastCategory = lineText; 
                                    return; 
                                }
                            }

                            // 헤더 행 무시
                            if (lineText.includes("Bib") || lineText.includes("배번호")) return;

                            // [데이터 추출] 첫 번째 요소가 숫자(Bib)인 경우만 처리
                            const cleanBib = texts[0]?.replace(/[^0-9]/g, '');
                            if (texts.length >= 5 && cleanBib && !isNaN(cleanBib)) {
                                let yearVal = is2025 ? "2025" : (is2023 ? "2023" : "2022");
                                let data = { year: yearVal, category: lastCategory };

                                if (!is2023 && !is2025) {
                                    // 2022년 로직
                                    KEYS_2022.forEach((key, idx) => {
                                        if (texts[idx]) data[key] = texts[idx];
                                    });
                                } else {
                                    // 2023년 & 2025년 로직
                                    let currentTargetKeys = MASTER_KEYS;
                                    let initKeys = MASTER_KEYS;

                                    if (is2023) {
                                        if (isHalf) {
                                            currentTargetKeys = KEYS_HALF_2023;
                                            initKeys = KEYS_HALF_2023;
                                        } else {
                                            currentTargetKeys = KEYS_2023;
                                            initKeys = KEYS_2023;
                                        }
                                    } else {
                                        // 2025년 등: 2025 Half는 상세 키셋 우선 적용 (컬럼 수 부족해도 매핑 시도)
                                        if ((is2025 && isHalf && texts.length >= 20) || texts.length >= 35) {
                                            currentTargetKeys = KEYS_HALF_DETAILED;
                                            initKeys = KEYS_HALF_DETAILED;
                                        }
                                    }

                                    initKeys.forEach(k => data[k] = ""); // 초기화

                                    // [2025 Half 상세 로직]
                                    if (currentTargetKeys === KEYS_HALF_DETAILED) {
                                        let tIdx = 0;
                                        // 0~2: 배번호, 한글이름, 영문이름
                                        for(let k=0; k<3; k++) data[currentTargetKeys[k]] = texts[tIdx++] || "";
                                        
                                        // 3: 단체명 (누락 가능성 있음)
                                        // 4: 종목 (Half Distance 등)
                                        const nextStr = texts[tIdx] || "";
                                        const isEventStr = /half|long|aqua|course/i.test(nextStr);
                                        
                                        if (isEventStr) {
                                            data[currentTargetKeys[3]] = ""; // 단체명 없음
                                        } else {
                                            data[currentTargetKeys[3]] = texts[tIdx++] || ""; // 단체명 있음
                                        }

                                        // 나머지 매핑
                                        for(let k=4; k<currentTargetKeys.length; k++) {
                                            data[currentTargetKeys[k]] = texts[tIdx++] || "";
                                        }

                                        // [필터] 칩타임 없으면 제외 (부문인원 체크는 Pro 선수 누락 원인이 되므로 제거)
                                        if (!data["칩타임"]) return;
                                    }
                                    // [2023 하프 특수 매핑] -null 컬럼 처리 및 State 누락 대응
                                    else if (is2023 && isHalf) {
                                        let tIdx = 0;
                                        // 1차 매핑
                                        currentTargetKeys.forEach(k => {
                                            if (k.endsWith("-null")) { data[k] = ""; }
                                            else { if (texts[tIdx]) data[k] = texts[tIdx]; tIdx++; }
                                        });

                                        // State 누락 감지 (State가 숫자이고 PlaceCat이 시간 형식이면 밀린 것)
                                        if (/^\d+$/.test(data["State"]) && /:/.test(data["PlaceCat"])) {
                                            tIdx = 0;
                                            currentTargetKeys.forEach(k => {
                                                if (k.endsWith("-null")) { data[k] = ""; }
                                                else if (k === "State") { data[k] = ""; } // State 건너뜀 (texts 소모 안함)
                                                else { if (texts[tIdx]) data[k] = texts[tIdx]; tIdx++; }
                                            });
                                        }
                                    }
                                    // [2023 풀코스 데이터 밀림 방지] State(인덱스4)가 비어있는 경우 감지
                                    else if (is2023 && !isHalf && currentTargetKeys === KEYS_2023 && texts.length > 10) {
                                        let skipMapping = false;
                                        // texts[4]가 숫자(순위)이고 texts[5]가 시간형식(기록)이면 State 누락으로 판단
                                        if (/^\d+$/.test(texts[4]) && /:/.test(texts[5])) {
                                            data["State"] = ""; // State 비움
                                            // 0~3까지는 정상 매핑
                                            for(let k=0; k<4; k++) data[currentTargetKeys[k]] = texts[k];
                                            // 5(PlaceCat)부터는 texts 인덱스 하나씩 당겨서 매핑
                                            for(let k=5; k<currentTargetKeys.length; k++) data[currentTargetKeys[k]] = texts[k-1];
                                            skipMapping = true;
                                        }
                                        
                                        if (!skipMapping) {
                                            currentTargetKeys.forEach((key, idx) => {
                                                if (texts[idx]) data[key] = texts[idx];
                                            });
                                        }
                                    } else {
                                        // 그 외 일반 매핑
                                        currentTargetKeys.forEach((key, idx) => {
                                            if (texts[idx]) data[key] = texts[idx];
                                        });
                                    }

                                    // [필터 2] RaceTime 자리에 성별이 들어간 경우(데이터 밀림) 제외
                                    if (data["RaceTime"] === "남" || data["RaceTime"] === "여") return;
                                    // [필터 3] 잘못된 배번 제외
                                    if (data["Bib"] === "0" || data["Bib"] === "") return;
                                    // [필터 4] PlaceCat 0 제외 (중도포기 등)
                                    if (data["PlaceCat"] === "0") return;
                                }
                                results.push(data);
                            }
                        });
                    }
                }

                downloadJSON(results, file.name);
                
            } catch (err) {
                console.error(err);
                alert("오류가 발생했습니다: " + err.message);
                document.getElementById('status').innerText = "오류 발생";
            }
        };
    </script>
</body>
</html>